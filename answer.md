# Вопрос 1. Какой самый эффективный способ конкатенации строк?

https://habr.com/ru/post/417479/

ConcatOperator - "+":
Берем две строки и возвращаем строку-результат. При этом нету гарантии, что будет возвращаться новая строка.

ConctatBuilder - strings.Builder:
```
func concat2builder(x, y string) string {
    var builder strings.Builder
    builder.Grow(len(x) + len(y)) // Только эта строка выделяет память
    builder.WriteString(x)
    builder.WriteString(y)
    return builder.String()
}
```

# Вопрос 2. Что такое интерфейсы, как они применяются в Go?

Интерфейс - это специальный тип в Go, который представляет набор сигнатур методов.

Импелементация интерфейса - это когда наш конкретный тип реализует все методы в интерфейсе.

Интерфейсное значение внутри хранит информацию о конкретном (неинтерфейсном типе) и его значение.

Пустой интерфейс - это интерфейс у которого нету метода. Любой тип в Go имплементирует пустой интерфейс. Его использует чтобы принимать любой тип данных.

Итнерфейсы используют в Go, чтобы абстрагироваться от типа данных. С помощью интерфейсов в Go реализуется полиморфизм.

# Вопрос 3. Чем отличаются RWMutex от Mutex?

Mutex - специальная структура из пакета sync.

Осовная цель - обеспечивает безопасный доступ к общим ресурсам.

Методы -  mu.Lock() и mu.Unlock()

RWMutex - позволяет разделить отдельно блокировку на запись и чтение.

Чтение - mu.RLock() и mu.RUnlock()

Запись - mu.Lock() и mu.Unlock()

Когда мы вызываем блокировку на чтение, она получает не эксклюзивную блокировку. В один момент времени все горутины могут читать значения. А во время записи, выполняется эксклюзивная блокировка. Все горутины которые выполняют чтение, не могут получить блокировку на чтение.

Таким образом операции чтения становятся общими, а операции записи требуют доступ.


# Вопрос 4. Чем отличаются буферизированные и не буферизированные каналы?

Каналы - это инструмент коммуникации, который позволяет обмениваться данными между горутинами.

У канала есть свойства:
1) Len - кол-во элементов, которые находятся в буфере
2) Cap - размер буфера канала

```
type chan struct {
  mx sync.mutex
  buffer []T //зависит от типа канала
  readers []Goroutines // очередь на чтение
  writers []Goroutines // очередь на запись
}
```

Не буферизированные каналы:

Иницилизация: make(chan int) | len(buffer) = 0

Обязательное условием записи и чтения: должен быть горутина в очереди. На каждую записывающую горутину, должна быть читающая и наоборот.

Записывать в закрытый канал нельзя и закрытие закрытого канала, вызывает panics

Буферизированные каналы:

Иницилизация: make(chan int, value) | len(buffer) > 0

Пока len <= cap, мы можем туда записывать значение. Если условие не выполняется, то появляется обязательное условие записи и чтения

Если заранее известно кол-во значений рекомендуется использовать буферизированный канал. Программа будет меньше блокироваться и работать быстрее.

# Вопрос 5. Какой размер у структуры struct{}{}?

Размер структуры struct{}{} = 0, в структурах выравнивание происходит по самому большому полю.

# Вопрос 6. Есть ли в Go перегрузка методов или операторов?

В Go нет перегрузки методов и функций. Предлагается просто давать разные имена методам и функциям.

# Вопрос 7. В какой последовательности будут выведены элементы map[int]int?

```
Пример:
m[0]=1
m[1]=124
m[2]=281
```

Тип map - это тип данных созданный на основе хэш-таблицы. Получается структура данных неупорядоченная, поэтому данные выведутся хаотично.

# Вопрос 8. В чем разница make и new?

Make:
- Используется только для slice, map, chan.
- Входящие параметры включают тип и размер.
- Возвращается сам тип.

New:
- Любая структура данных.
- Допускается один параметр типа, без размера.
- Возвращается указатель.

```
mapNew := *new(map[string]string)
mapMake := make(map[string]string, 3)
```

# Вопрос 9. Сколько существует способов задать переменную типа slice или map?

Способ 1. Make:

```
sliceMake := make([]int, 0, 5) // если один элемент, то это изначальное кол-во аргументов
mapMake := make(map[string]string, 3)
```

Способ 2. New:

```
sliceNew := *new([]string)
mapNew := *new(map[string]string)
```

Способ 3. Default:

```
var sliceDefault []string
var mapDefault map[string]string
```


Способ 3. Slice by literal:

```
sliceLiteral := []string{"First", "Second"}
mapLiteral := map[stsring]int{"House": 1, "Dom": 2}
```

# Вопрос 10. Что выведет данная программа и почему?

```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

```
1
1
```

Тип переменных:
- a - int
- p - *int

В функцию update передается копия указателя *p, тем самым мы меняем значение у копии.
Чтобы в коде изменилось значение нужно передавать по двойному указателю  p.

# Вопрос 11. Что выведет данная программа и почему?

```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Функция выведет числа в порядке, как отработали горутины от 0 до 4 и следом сообщение о ошибке "panic: sync: negative WaitGroup counter"

Сообщение о ошибке сигнализируе о том, что произошел deadlock. Возникает из-за того, что в функцию передается копия WaitGroup. Счетчик не изменяется и программа вечно ждет остановки горутин.

Решение проблему передавать WaitGroup по указателю.


# Вопрос 12. Что выведет данная программа и почему?

```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

```
0
```

Так-как переменная n иницилизируется в главной функции и в условие. Следовательно n имеет область видимости только в главной функции, ее значение будет равно нулю. 

# Вопрос 13. Что выведет данная программа и почему?

```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

```
[100 2 3 4 5]
```

Иницилизируется слайс с len = cap = 5. В функцию передается ссылка на значение элементов массива, на который ссылается данный слайс. Тем самым мы можем изменить значения в слайсе, но с емкостью такое не получиться.


# Вопрос 14 .Что выведет данная программа и почему?

```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

```
[b b a][a a]
```

Решение аналогично 13 задачи, изменения в анонимной функции происходят с копией слайса.
